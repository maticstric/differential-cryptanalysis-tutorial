<div id="sidebar">
</div>
<section id="content">
  <header>
    <img id="logo" src="images/logo.svg" width="80" />
    <h1>Differential Cryptanalysis Tutorial</h1>
  </header>
  <section>
    <h2>Abstract</h2>
    <p>This tutorial is a detailed and interactive introduction to differential cryptanalysis, a subtle, beautiful, and powerful method of breaking some of the world’s strongest ciphers. Unlike other currently available tutorials, it avoids needless math notation, makes very few assumptions about prior knowledge, does not gloss over details, and is written to be understood by novices with an interest in cryptography.</p>
    <p>Before continuing, know that there are two major prerequisites:</p>
    <ul>
      <li>You must be comfortable with binary and hexidecimal notation, especially how to convert between them</li>
      <li>We will be using differential cryptanalysis to break symmetric-key block ciphers. You should be familiar with this family of ciphers before learning a technique to break them</li>
    </ul>
  </section>
  <section>
    <h2>Introduction</h2>
    <p>Differential cryptanalysis was first discovered in the 1970s by the designers of the Data Encryption Standard (DES) at IBM. After a consultation with the NSA, the DES designers opted to keep the techinque a secret, because its release “would weaken the competitive advantage the United States enjoyed over other countries in the field of cryptography” {cite(biham)}. It remained classified until it was independently rediscovered and published in the early 1990s by Eli Biham and Adi Shamir, who are now credited with its discovery {cite(coppersmith)}.</p>
    <p>Before getting to the definition, it is important to note that differential cryptanalysis is what’s known as a <em class="highlight">chosen plaintext</em> attack. This means that we, as attackers, may choose which plaintexts, and how many, we want encrypted by the cipher using the same secret key. This may not always be true in the real world since the same key often isn’t used for a very long time, and during that time it can be difficult or impossible to encrypt whichever plaintext you wish. Nevertheless, we must make this assumption for the attack to work.</p>
    <p>Note that the final goal of differential cryptanalysis is not simply to decrypt a secret message. We want to get the secret key which was used to encrypt the message, so that we can decrypt any other message sent using the same key.</p>
    <hr/>
    <p>Block ciphers work by repeatedly applying a set of transformations (key addition, substitution, permutation, etc.) to a plaintext, until a ciphertext is obtained. The security of the cipher depends on the attacker never knowing/guessing any intermediate value during encryption; we can only see the plaintext (remember, chosen plaintext) and ciphertext, nothing more. As you will see in section 4 of this tutorial, if an intermediate value could be guessed, the security of the cipher would be immediately compromised.</p>
    <p>However, as we will explain thoroughly in this tutorial, we <em>can</em> know/guess the intermediate value of the <em>difference of two plaintexts</em> during encryption (this is why the technique is called <em>differential</em> cryptanalysis). This is a very subtle point and one that can be difficult to understand initially, but is paramount to understanding how differential cryptanalysis can recover the secret key and therefore break the cipher.</p>
    <p>As you will see, this “difference” is measured via a simple bitwise XOR of the two plaintexts.</em>
    <p>Now that we have the basics, let’s get to breaking our first cipher!</p>
  </section>
  <section>
    <h2>Components of Block Ciphers</h2>
    <p>This section is a short refresher on the components which make up the block ciphers we’ll be breaking. If you feel confident in your knowledge of key addition, SBOXes, and PBOXes, you are encouraged to skip this section.</p>
    <section>
      <h3>Block Ciphers</h3>
      <p>Block ciphers are symmetric key encryption algorithms which operate on a fixed-length <em>block</em> of bits. They take a fixed-length block as input and output an encrypted block of the same length. Decryption is done by running the encypted block backwards through the cipher. There are many ways to construct block ciphers, but most are made up of a repeated sequence of three simple transformations: key addition, substitution, and permutation.</p>
    </section>
    <section>
      <h3>Key Addition</h3>
      <p>Key addition is the step in which we introduce the secret/symmetric key. We do this by a bit-wise XOR of the key with the block. Remember that the XOR of two bits is defined by this function:</p>
      <table class="monospaced-table" id="xor">
        <tr>
          <td><i>b</i><sub>1</sub></td>
          <td><i>b</i><sub>2</sub></td>
          <td><i>b</i><sub>1</sub> ⊕ <i>b</i><sub>2</sub></td>
        </tr>
        <tr>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <td>0</td>
          <td>1</td>
          <td>1</td>
        </tr>
        <tr>
          <td>1</td>
          <td>0</td>
          <td>1</td>
        </tr>
        <tr>
          <td>1</td>
          <td>1</td>
          <td>0</td>
        </tr>
      </table>
      <p>If, for example, our secret key was the bit string 11010010 and we had a block of bits, which <em>before</em> the key addition step had a value of 01101110 (block size is one byte), the value of the block <em>after</em> the key addition would be:</p>
      <table id="key-addition">
        <tr>
          <td></td>
          <td>01101110</td>
        </tr>
        <tr>
          <td>⊕</td>
          <td>11010010</td>
        </tr>
        <tr>
          <td></td>
          <td>10111100</td>
        </tr>
      </table>
    </section>
    <section>
      <h3>Substitution</h3>
      <p>Substitution is the step in which some bits are directly substituted for others. We define how these bits are substituted with a substitution-box (SBOX). Let’s define a simple 4-bit SBOX:
      <table class="monospaced-table" id="substitution">
        <tr>
          <th colspan="17">SBOX</th>
        </tr>
        <tr>
          <th>Input:</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
          <td>3</td>
          <td>4</td>
          <td>5</td>
          <td>6</td>
          <td>7</td>
          <td>8</td>
          <td>9</td>
          <td>a</td>
          <td>b</td>
          <td>c</td>
          <td>d</td>
          <td>e</td>
          <td>f</td>
        </tr>
        <tr>
          <th>Output:</th>
          <td>e</td>
          <td>4</td>
          <td>d</td>
          <td>1</td>
          <td>2</td>
          <td>f</td>
          <td>b</td>
          <td>8</td>
          <td>3</td>
          <td>a</td>
          <td>6</td>
          <td>c</td>
          <td>5</td>
          <td>9</td>
          <td>0</td>
          <td>7</td>
        </tr>
      </table>
      <p>Note that both the input and output are represented using hexadecimal notation. As an example, if the input to this SBOX is 1011 (0xb), then we’ll get an output of 1100 (0xc) by simply looking it up in the table.</p>
      <p>The SBOX that a cipher uses is almost always released to the public. This is done in accordance with Kerckhoffs’s principle which says that a cryptosystem should be secure even if everything about it―with the exception of the secret keys―is public knowledge. Just because the SBOX is public and therefore easily reversible does not mean that substitution is pointless or insignificant. In fact, it is often the only part of a cipher which directly protects against differential cryptanalysis. Consequently, we’ll discuss substitution in much more depth throughout this tutorial.</p>
    </section>
    <section>
      <h3>Permutation</h3>
      <p>Permutation is a step in which we change the position of the bits. We define how these bits are permutated with a permutation-box (PBOX). Let’s define a simple 4-bit PBOX:</p>
      <table class="monospaced-table" id="permutation-4">
        <tr>
          <th colspan="17">PBOX</th>
        </tr>
        <tr>
          <th>Input:</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
          <td>3</td>
        </tr>
        <tr>
          <th>Output:</th>
          <td>3</td>
          <td>0</td>
          <td>2</td>
          <td>1</td>
        </tr>
      </table>
      <p>This PBOX says that the bit at position 0 will move to position 3, the bit at position 1 will move to position 0, the bit at position 2 will stay at position 2, and the bit at position 3 will move to position 1. For example, if we input the nibble 1001 into the PBOX, we will get an output of 0101. PBOXes, unlike SBOXes, are easy to represent visually:</p>
      {{../images/pbox.svg}}
      <p>Just like SBOXes, PBOXes are released to the public. Though SBOXes serve as the main protection against differential cryptanalysis, PBOXes also play a vital role which we will discuss later.</p>
      <p>
    </section>
  </section>
  <section>
    <header>
      <h2>Toy Cipher</h2>
      <blockquote>
        <p>If you can’t solve a problem, then there is an easier problem you can’t solve: find it.</p>
        <cite>—Pólya/Conway</cite>
      </blockquote>
    </header>
    <p>Let’s begin by breaking the simplest block cipher worth breaking which we’ll call the “toy cipher.” The toy cipher is <em>just</em> complicated enough to make differential cryptanalysis a valid method to break it, but no more. Note that it is trivial to break the toy cipher by bruteforce. Nevertheless, it will serve as a great introduction to the main concepts behind differential cryptanalysis.</p>
    <section>
      <h3>Toy Cipher Definition</h3>
      <p>The toy cipher has a block size of 4 bits (also known as a nibble), meaning that we’ll input 4 bits into the cipher and it will return 4 bits of ciphertext. The toy cipher has a 4-bit SBOX and two separate 4-bit keys (<i>k</i><sub>1</sub> and <i>k</i><sub>2</sub>).</p>
      <p>Now let’s look at how we can encrypt a nibble with the toy cipher. There are three steps:</p>
      <ol>
        <li>We XOR the plaintext with <i>k</i><sub>1</sub></li>
        <li>Feed that result into the SBOX</li>
        <li>XOR the output of the SBOX with <i>k</i><sub>2</sub></li>
      </ol>
      <p>These simple steps give us the final ciphertext. The cipher is much easier to understand visually so look to the figure below. The values underlined with purple can be changed, so play around with them to see how the cipher is affected. The red lines represent the 1s and the black lines the 0s as the nibble makes its way through the cipher. Also note the labels <i>x</i>, <i>u</i>, <i>v</i>, and <i>y</i> on the left (<i>x</i> is the value of the plaintext, <i>u</i> is the value after the first key addition, etc.). Those labels will make it easier to discuss the cipher when we get to differential cryptanalysis so keep them in mind.</p>
      {{toy-visualization.html}}
    </section>
    <section>
      <h3>Differential Cryptanalysis of the Toy Cipher</h3>
      <p>Much of the following is based on King’s webpage: “Differential Cryptanalysis Tutorial” {cite(king)} as well as Stinson’s textbook <i>Cryptography: Theory and Practice</i> {cite(stinson)}.</p>
      <p>We must begin by selecting which SBOX we’ll be using for the toy cipher. Remember that SBOXes are public knowledge and that, once the cipher is defined, they do not change. So, we’ll pick an arbitrary SBOX for our toy cipher.</p>
      <table class="monospaced-table" id="substitution">
        <tr>
          <th colspan="17">SBOX</th>
        </tr>
        <tr>
          <th>Input:</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
          <td>3</td>
          <td>4</td>
          <td>5</td>
          <td>6</td>
          <td>7</td>
          <td>8</td>
          <td>9</td>
          <td>a</td>
          <td>b</td>
          <td>c</td>
          <td>d</td>
          <td>e</td>
          <td>f</td>
        </tr>
        <tr>
          <th>Output:</th>
          <td>e</td>
          <td>4</td>
          <td>d</td>
          <td>1</td>
          <td>2</td>
          <td>f</td>
          <td>b</td>
          <td>8</td>
          <td>3</td>
          <td>a</td>
          <td>6</td>
          <td>c</td>
          <td>5</td>
          <td>9</td>
          <td>0</td>
          <td>7</td>
        </tr>
      </table>
      <p>Differential cryptanalysis stems from the analysis of the XOR of two plaintexts as they travel through the cipher. The reason XOR is used is because it tells us where two plaintexts differ. If their XOR at some bit position is 1, then those two plaintexts differ at that bit position.</p>
      <p>For now, instead of focusing on the cipher as a whole, we’ll simply analyze the SBOX. Let’s first choose an XOR value to analyze: 1011. We can make a table of all possible pairs of SBOX inputs, call them <i>x</i> and <i>x</i><sup>*</sup>, which XOR to 1011 (in other words, all inputs which differ in the first, third, and fourth bit positions).</p>
      <table class="monospaced-table" id="xor-input-table">
        <tr>
          <th><i>x</i></th>
          <th><i>x</i><sup>*</sup></th>
          <th><i>x</i> ⊕ <i>x</i><sup>*</sup></th>
        </tr>
        <tr>
          <td>0000</td>
          <td>1011</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>0001</td>
          <td>1010</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>0010</td>
          <td>1001</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>0011</td>
          <td>1000</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>0100</td>
          <td>1111</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>0101</td>
          <td>1110</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>0110</td>
          <td>1101</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>0111</td>
          <td>1100</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>1000</td>
          <td>0011</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>1001</td>
          <td>0010</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>1010</td>
          <td>0001</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>1011</td>
          <td>0000</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>1100</td>
          <td>0111</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>1101</td>
          <td>0110</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>1110</td>
          <td>0101</td>
          <td>1011</td>
        </tr>
        <tr>
          <td>1111</td>
          <td>0100</td>
          <td>1011</td>
        </tr>
      </table>
      <p>Now, let’s consider the XOR of the SBOX <em>outputs</em> of both <i>x</i> and <i>x</i><sup>*</sup>. Let’s name those outputs <i>y</i> and <i>y</i><sup>*</sup> respectively. In other words, if we put the input <i>x</i> through the SBOX we defined earlier, we’ll get <i>y</i>, and if we input <i>x</i><sup>*</sup>, we’ll get <i>y</i><sup>*</sup>.</p>
      <table class="monospaced-table" id="xor-input-output-table">
        <tr>
          <th><i>x</i></th>
          <th><i>x</i><sup>*</sup></th>
          <th><i>x</i> ⊕ <i>x</i><sup>*</sup></th>
          <th><i>y</i></th>
          <th><i>y</i><sup>*</sup></th>
          <th><i>y</i> ⊕ <i>y</i><sup>*</sup></th>
        </tr>
        <tr>
          <td>0000</td>
          <td>1011</td>
          <td>1011</td>
          <td>1110</td>
          <td>1100</td>
          <td>0010</td>
        </tr>
        <tr>
          <td>0001</td>
          <td>1010</td>
          <td>1011</td>
          <td>0100</td>
          <td>0110</td>
          <td>0010</td>
        </tr>
        <tr>
          <td>0010</td>
          <td>1001</td>
          <td>1011</td>
          <td>1101</td>
          <td>1010</td>
          <td>0111</td>
        </tr>
        <tr>
          <td>0011</td>
          <td>1000</td>
          <td>1011</td>
          <td>0001</td>
          <td>0011</td>
          <td>0010</td>
        </tr>
        <tr>
          <td>0100</td>
          <td>1111</td>
          <td>1011</td>
          <td>0010</td>
          <td>0111</td>
          <td>0101</td>
        </tr>
        <tr>
          <td>0101</td>
          <td>1110</td>
          <td>1011</td>
          <td>1111</td>
          <td>0000</td>
          <td>1111</td>
        </tr>
        <tr>
          <td>0110</td>
          <td>1101</td>
          <td>1011</td>
          <td>1011</td>
          <td>1001</td>
          <td>0010</td>
        </tr>
        <tr>
          <td>0111</td>
          <td>1100</td>
          <td>1011</td>
          <td>1000</td>
          <td>0101</td>
          <td>1101</td>
        </tr>
        <tr>
          <td>1000</td>
          <td>0011</td>
          <td>1011</td>
          <td>0011</td>
          <td>0001</td>
          <td>0010</td>
        </tr>
        <tr>
          <td>1001</td>
          <td>0010</td>
          <td>1011</td>
          <td>1010</td>
          <td>1101</td>
          <td>0111</td>
        </tr>
        <tr>
          <td>1010</td>
          <td>0001</td>
          <td>1011</td>
          <td>0110</td>
          <td>0100</td>
          <td>0010</td>
        </tr>
        <tr>
          <td>1011</td>
          <td>0000</td>
          <td>1011</td>
          <td>1100</td>
          <td>1110</td>
          <td>0010</td>
        </tr>
        <tr>
          <td>1100</td>
          <td>0111</td>
          <td>1011</td>
          <td>0101</td>
          <td>1000</td>
          <td>1101</td>
        </tr>
        <tr>
          <td>1101</td>
          <td>0110</td>
          <td>1011</td>
          <td>1001</td>
          <td>1011</td>
          <td>0010</td>
        </tr>
        <tr>
          <td>1110</td>
          <td>0101</td>
          <td>1011</td>
          <td>0000</td>
          <td>1111</td>
          <td>1111</td>
        </tr>
        <tr>
          <td>1111</td>
          <td>0100</td>
          <td>1011</td>
          <td>0111</td>
          <td>0010</td>
          <td>0101</td>
        </tr>
      </table>
      <p>Here we see the heart of differential cryptanalysis. Examine the values of <i>y</i> ⊕ <i>y</i><sup>*</sup> and notice the repetitions. Let’s create another table to see how many times each value appears in the SBOX output XORs.</p>
      <table class="monospaced-table" id="xor-appearances-table">
        <tr>
          <th>Output XOR</th>
          <th>Appearances</th>
        </tr>
        <tr>
          <td>0000</td>
          <td>0</td>
        </tr>
        <tr>
          <td>0001</td>
          <td>0</td>
        </tr>
        <tr>
          <td>0010</td>
          <td class="highlight">8</td>
        </tr>
        <tr>
          <td>0011</td>
          <td>0</td>
        </tr>
        <tr>
          <td>0100</td>
          <td>0</td>
        </tr>
        <tr>
          <td>0101</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <td>0110</td>
          <td>0</td>
        </tr>
        <tr>
          <td>0111</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <td>1000</td>
          <td>0</td>
        </tr>
        <tr>
          <td>1001</td>
          <td>0</td>
        </tr>
        <tr>
          <td>1010</td>
          <td>0</td>
        </tr>
        <tr>
          <td>1011</td>
          <td>0</td>
        </tr>
        <tr>
          <td>1100</td>
          <td>0</td>
        </tr>
        <tr>
          <td>1101</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <td>1110</td>
          <td>0</td>
        </tr>
        <tr>
          <td>1111</td>
          <td class="highlight">2</td>
        </tr>
      </table>
      <p>Consider what this table is really saying. If we pick two random plaintexts which XOR to 1011, put each of them through the SBOX, and then XOR those SBOX outputs, 8 out of 16 times, they will XOR to 0010. They will XOR to 0111 2 out of 16 times. They will never XOR to 1010. This bias towards certain XORs is what makes differential cryptanalysis possible.</p>
      <p>So far we’ve only considered the input XOR of 1011. We can repeat the same process for every possible input XOR and build what is called a <em class="highlight">difference distribution table</em> for the given SBOX. The rows in this table represent the SBOX input XOR, the columns represent the SBOX output XOR, and the cell values are the number of appearances of that output XOR given the input XOR. Note that the XORs are represented in hexadecimal instead of binary (e.g. you can find the previous example of 1011 in the row labeled b).</p>
      <table class="monospaced-table" id="difference-distribution-table">
        <tr>
          <th>Input</th>
          <th colspan="16">Output XOR</th>
        </tr>
        <tr>
          <th>XOR</th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>a</th>
          <th>b</th>
          <th>c</th>
          <th>d</th>
          <th>e</th>
          <th>f</th>
        </tr>
        <tr>
          <th>0</th>
          <td class="highlight">16</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <th>6</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <th>7</th>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
        </tr>
        <tr>
          <th>8</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <th>9</th>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>a</th>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0</td>
          <td>0</td>
          <td class="highlight">8</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
        </tr>
        <tr>
          <th>e</th>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
        </tr>
        <tr>
          <th>f</th>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
        </tr>
      </table>
      <hr/>
      <p>This table gives us probabilities for what happens to the XOR of two plaintexts as they individually travel through the SBOX. However, besides the SBOX, the cipher also includes key addition. So, before we get to breaking the keys, we must consider what happens to the XOR of two plaintexts as we put them through key addition.</p>
      <p>Let’s consider two plaintexts:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p><i>x</i> = 0111</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>x</i><sup>*</sup> = 1100</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>x</i> ⊕ <i>x</i><sup>*</sup> = <span class="highlight">1011</span></p>
          </td>
        </tr>
      </table>
      <p>Now let’s choose a key that we’ll add to both:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p><i>k</i> = 1010</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>x</i> ⊕ <i>k</i> = 0111 ⊕ 1010 = 1101</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>x</i><sup>*</sup> ⊕ <i>k</i> = 1100 ⊕ 1010 = 0110</p>
          </td>
        </tr>
      </table>
      <p>Now let’s see what value we get when we XOR the outputs of this key addition:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p>(<i>x</i> ⊕ <i>k</i>) ⊕ (<i>x</i><sup>*</sup> ⊕ <i>k</i>) = 1101 ⊕ 0110 = <span class="highlight">1011</span></p>
          </td>
        </tr>
      </table>
      <p>You should see that both <i>x</i> ⊕ <i>x</i><sup>*</sup> and (<i>x</i> ⊕ <i>k</i>) ⊕ (<i>x</i><sup>*</sup> ⊕ <i>k</i>) come out to the same value. This should be apparent because of a few mathematical facts: XOR is associative, XOR is commutative, a value XORed by itself is zero, and a value XORed by zero is itself. We can therefore prove the previous statement like so:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p>(<i>x</i> ⊕ <i>k</i>) ⊕ (<i>x</i><sup>*</sup> ⊕ <i>k</i>)</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>= <i>x</i> ⊕ <i>x</i><sup>*</sup> ⊕ <i>k</i> ⊕ <i>k</i></p>
          </td>
        </tr>
        <tr>
          <td>
            <p>= <i>x</i> ⊕ <i>x</i><sup>*</sup> ⊕ 0</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>= <i>x</i> ⊕ <i>x</i><sup>*</sup></p>
          </td>
        </tr>
      </table>
      <p>This is an incredibly useful realization. Given the XOR of two plaintexts, we can predict with 100% certainty what their XOR will be after key addition—it will always stay the same. Remember that with the SBOX, the best prediction we have is only 50%, and many are much worse than that.</p>
      <p>The fact that keys become essentially useless when we use this attack should convince us that we’re on the right track. This is also why SBOXes are an absolutely <em>essential</em> part of many ciphers. You will see in the next section that even when we also consider permutations, SBOXes are still the only protection against attacks like differential cryptanalysis.</p>
      <hr/>
      <p>Now we can begin breaking the keys.</p>
      <p>Because differential cryptanalysis is a chosen plaintext attack we’ll need to encrypt plaintexts in order to break the keys. For that, however, we need to choose which keys will be used for encryption. For now let’s assume that <i>k</i><sub>1</sub> = 0xb and <i>k</i><sub>2</sub> = 0xd. Of course, when differential cryptanalysis is used in the real world the keys are unknown to the attackers. But some keys <em>need</em> to be chosen and this is just a tutorial so we might as well know them beforehand.</p>
      <p>The first step is to pick a <em class="highlight">differential characteristic</em> (this is just an input and output XOR pair). Let’s just choose a random one which has a non-zero value in the difference distribution table: 0x5 ➝ 0xa.</p>
      <p>Next we must find a pair of plaintexts which XOR to 0x5 and whose associated ciphertexts XOR to 0xa. Such a pair is called a <em class="highlight">good pair</em> for that given differential characteristic. You will see how a good pair is useful in a second.</p>
      <p>Assuming <i>k</i><sub>1</sub> = 0xb and <i>k</i><sub>2</sub> = 0xd, one good pair is 0x6 and 0x3. They XOR to 0x5. They encrypt to 0x4 and 0xe respectively, and 0x4 ⊕ 0xe = 0xa. This matches our differential characteristic. You can confirm this using the toy cipher visualization at the beginning of this section or by hand.</p>
      <div class="visualization">
        <div class="figure">
          {{../images/toy-dc-unfinished.svg}}
        </div>
      </div>
      <p>Now let’s see how this good pair will travel through the cipher. Above is a figure showing what is being explained here. We’ll be referencing the letters on the sides of the figure.</p>
      <p>We know that at <i>x</i> the value on the left is 0x6, the value on the right is 0x3, and their XOR is 0x5. We also know that at <i>y</i> the value on the left is 0x4, the value on the right is 0xe, and their XOR is 0xa. These are all values which we’ve hand picked. Now, what is the XOR at <i>u</i>? As explained earlier, the XOR doesn’t change over key addition, so it remains at 0x5. Since the XOR at <i>y</i> is 0xa, we can follow the same logic and conclude that the XOR at <i>v</i> must also be 0xa.</p>
      <p>But what are the values at <i>u</i> and <i>v</i>?</p>
      <p>Assuming the keys are unknown to us, there’s no easy way to tell. However, we do know that whatever the values at <i>u</i> are, they must XOR to 0x5 and whatever the values at <i>v</i> are, they must XOR to 0xa. Well, what are the possible inputs to an SBOX which XOR to 0x5 and whose corresponding SBOX outputs XOR to 0xa? We’ve already calculated them when making the difference distribution table! The calculation was not shown previously (we only saw the one for an SBOX input XOR of 0xb) so let’s see it now:</p>
      <table class="monospaced-table" id="xor-input-output-table-0x5">
        <tr>
          <th><i>x</i></th>
          <th><i>x</i><sup>*</sup></th>
          <th><i>x</i> ⊕ <i>x</i><sup>*</sup></th>
          <th><i>y</i></th>
          <th><i>y</i><sup>*</sup></th>
          <th><i>y</i> ⊕ <i>y</i><sup>*</sup></th>
        </tr>
        <tr>
          <td>0000</td>
          <td>0101</td>
          <td>0101</td>
          <td>1110</td>
          <td>1111</td>
          <td>0001</td>
        </tr>
        <tr>
          <td>0001</td>
          <td>0100</td>
          <td>0101</td>
          <td>0100</td>
          <td>0010</td>
          <td>0110</td>
        </tr>
        <tr>
          <td>0010</td>
          <td>0111</td>
          <td>0101</td>
          <td>1101</td>
          <td>1000</td>
          <td>0101</td>
        </tr>
        <tr class="highlight">
          <td>0011</td>
          <td>0110</td>
          <td>0101</td>
          <td>0001</td>
          <td>1011</td>
          <td>1010</td>
        </tr>
        <tr>
          <td>0100</td>
          <td>0001</td>
          <td>0101</td>
          <td>0010</td>
          <td>0100</td>
          <td>0110</td>
        </tr>
        <tr>
          <td>0101</td>
          <td>0000</td>
          <td>0101</td>
          <td>1111</td>
          <td>1110</td>
          <td>0001</td>
        </tr>
        <tr class="highlight">
          <td>0110</td>
          <td>0011</td>
          <td>0101</td>
          <td>1011</td>
          <td>0001</td>
          <td>1010</td>
        </tr>
        <tr>
          <td>0111</td>
          <td>0010</td>
          <td>0101</td>
          <td>1000</td>
          <td>1101</td>
          <td>0101</td>
        </tr>
        <tr class="highlight">
          <td>1000</td>
          <td>1101</td>
          <td>0101</td>
          <td>0011</td>
          <td>1001</td>
          <td>1010</td>
        </tr>
        <tr>
          <td>1001</td>
          <td>1100</td>
          <td>0101</td>
          <td>1010</td>
          <td>0101</td>
          <td>1111</td>
        </tr>
        <tr>
          <td>1010</td>
          <td>1111</td>
          <td>0101</td>
          <td>0110</td>
          <td>0111</td>
          <td>0001</td>
        </tr>
        <tr>
          <td>1011</td>
          <td>1110</td>
          <td>0101</td>
          <td>1100</td>
          <td>0000</td>
          <td>1100</td>
        </tr>
        <tr>
          <td>1100</td>
          <td>1001</td>
          <td>0101</td>
          <td>0101</td>
          <td>1010</td>
          <td>1111</td>
        </tr>
        <tr class="highlight">
          <td>1101</td>
          <td>1000</td>
          <td>0101</td>
          <td>1001</td>
          <td>0011</td>
          <td>1010</td>
        </tr>
        <tr>
          <td>1110</td>
          <td>1011</td>
          <td>0101</td>
          <td>0000</td>
          <td>1100</td>
          <td>1100</td>
        </tr>
        <tr>
          <td>1111</td>
          <td>1010</td>
          <td>0101</td>
          <td>0111</td>
          <td>0110</td>
          <td>0001</td>
        </tr>
      </table>
      <p>The highlighted rows give us the four possible SBOX input pairs which XOR to 0x5, whose respective outputs XOR to 0xa. With this information, we can update the previous figure:</p>
      <div class="visualization">
        <div class="figure">
          {{../images/toy-dc-finished.svg}}
        </div>
      </div>
      <p>If we know the value at <i>x</i>, <i>u</i>, <i>v</i>, and <i>y</i>, we can simply calculate the value of the first and second key! By definition, we know:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p><i>x</i> ⊕ <i>k</i><sub>1</sub> = <i>u</i></p>
          </td>                   
        </tr>                     
        <tr>                      
          <td>                    
            <p><i>v</i> ⊕ <i>k</i><sub>2</sub> = <i>y</i></p>
          </td>
        </tr>
      </table>
      <p>Using simple XOR rules we can conclude that:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p><i>k</i><sub>1</sub> = <i>x</i> ⊕ <i>u</i></p>
          </td>                       
        </tr>                                    
        <tr>                                     
          <td>                                   
            <p><i>k</i><sub>2</sub> = <i>v</i> ⊕ <i>y</i></p>
          </td>
        </tr>
      </table>
      <p>Since there are only four possible values of <i>u</i> and <i>v</i>, we’ve narrowed down the possibilities for the two keys from 256 to only 4 (in the table, the subscripts <i>l</i> and <i>r</i> refer to the left and right values in the figure above):</p>
      <table class="monospaced-table" id="toy-keys">
        <tr>
          <th><i>x<sub>l</sub></i></th>
          <th><i>u<sub>l</sub></i></th>
          <th><i>v<sub>l</sub></i></th>
          <th><i>y<sub>l</sub></i></th>
          <th><i>x<sub>r</sub></i></th>
          <th><i>u<sub>r</sub></i></th>
          <th><i>v<sub>r</sub></i></th>
          <th><i>y<sub>r</sub></i></th>
          <th>
            <i>x<sub>l</sub></i> ⊕ <i>u<sub>l</sub></i> =<br/>
            <i>x<sub>r</sub></i> ⊕ <i>u<sub>r</sub></i> =<br/>
            <i>k</i><sub>1</sub>
          </th>
          <th>
            <i>v<sub>l</sub></i> ⊕ <i>y<sub>l</sub></i> =<br/>
            <i>v<sub>r</sub></i> ⊕ <i>y<sub>r</sub></i> =<br/>
            <i>k</i><sub>2</sub>
          </th>
        </tr>
        <tr>
          <td>0x6</td>
          <td>0x3</td>
          <td>0x1</td>
          <td>0x4</td>
          <td>0x3</td>
          <td>0x6</td>
          <td>0xb</td>
          <td>0xe</td>
          <td>0x5</td>
          <td>0x5</td>
        </tr>
        <tr>
          <td>0x6</td>
          <td>0x6</td>
          <td>0xb</td>
          <td>0x4</td>
          <td>0x3</td>
          <td>0x3</td>
          <td>0x1</td>
          <td>0xe</td>
          <td>0x0</td>
          <td>0xf</td>
        </tr>
        <tr>
          <td>0x6</td>
          <td>0x8</td>
          <td>0x3</td>
          <td>0x4</td>
          <td>0x3</td>
          <td>0xd</td>
          <td>0x9</td>
          <td>0xe</td>
          <td>0xe</td>
          <td>0x7</td>
        </tr>
        <tr>
          <td>0x6</td>
          <td>0xd</td>
          <td>0x9</td>
          <td>0x4</td>
          <td>0x3</td>
          <td>0x8</td>
          <td>0x3</td>
          <td>0xe</td>
          <td class="highlight">0xb</td>
          <td class="highlight">0xd</td>
        </tr>
      </table>
    </section>
    <p>You can see that one of the possible key guesses is correct! Remember that we set <i>k</i><sub>1</sub> = 0xb and <i>k</i><sub>2</sub> = 0xd earlier. Had we not known the keys beforehand, we would have had to loop through these 4 possible key combinations and find the keys that will give us the correct ciphertext for a given plaintext.</p>
    <hr/>
    <p>Let’s do a quick review of the steps we took to get here:</p>
    <ul>
      <li>We started by making the difference distribution table for the given SBOX</li>
      <li>We then randomly picked a differential characteristic with a non-zero probability</li>
      <li>We found a plaintext-ciphertext pair which matched that differential characteristic</li>
      <li>Using that good pair we narrowed down the values at <i>u</i> and <i>v</i> to only four possibilities</li>
      <li>Those also narrowed down the possible key combinations to four</li>
      <li>Since we already knew which one was correct, we just picked it out. Had we not known, we would have had to verify all four combinations with some plaintext-ciphertext pairs</li>
    </ul>
    <p>All of these steps are implemented in a Python script available in the <a href="https://github.com/maticstric/differential-cryptanalysis-tutorial/blob/master/toy-cipher-diff-crypt.py">GitHub repository</a>. You are <em>highly</em> encouraged to check it out, as it was made to accompany this tutorial and follows the exact same steps that we’ve taken. You can change the SBOX, key combinations, see some of the implementation details which were not discussed, and play around with the code in order to gain a deeper understading of this section.</p>
    <hr/>
    <p>Though the toy cipher served as a great introduction to many of the concepts and vocabulary of differential cryptanalysis, it’s called the <em>toy</em> cipher for a reason. It is so easily broken by brute force that these steps seem unnecessarily complicated. In the next section, you will see a more realistic application of differential cryptanalysis to break a non-trivial cipher.</p>
    <hr/>
    <footer>
      <blockquote>
        <p>Here I pause. If you wish to walk no farther with me, reader, I cannot blame you. It is no easy road.</p>
        <cite>—Wolfe</cite>
      </blockquote>
    </footer>
  </section>
  <section>
    <header>
      <h2>SPN</h2>
      <blockquote>
        <p>Simplicity does not precede complexity, but follows it.</p>
        <cite>—Perlis</cite>
      </blockquote>
    </header>
    <p>This section expands on the knowledge gained in the previous. We will discuss how differential cryptanalysis can be applied to more complicated ciphers which resemble the Advanced Encryption Standard (AES). Though the heart of the method will remain the same, the complexity of these ciphers will require the introduction of some new concepts.</p>
    <section>
      <h3>SPN Definition</h3>
      <p>A substitution-permutation network (SPN) is any kind of cipher which uses both substitution and permutation together with key addition. Because an SPN is so general (it can have any block size, SBOX size, number of rounds, etc.) and because differential cryptanalysis depends a lot on the structure of the cipher, we’ll be focusing on a particular SPN. Nevertheless, these steps could be taken for any kind of SPN.</p>
      <p>We will be using an SPN with a block size of 16 bits. It will have a total of four rounds. Each round, with the exception of the fourth, will consist of the following operations:</p>
      <ol>
        <li>Key addition with a 16 bit key</li>
        <li>We will then consider the 16 bits as 4 nibbles and put each of those nibbles through a 4-bit SBOX</li>
        <li>Lastly we will permutate the block with a 16-bit PBOX</li>
      </ol>
      <p>The fourth round will be the same as the previous, but without the permutation (because it actually provides no additional security). We will also end the cipher with one last key addition.</p>
      <p>This means that we will need five 16-bit keys. The total number of key bits we need to break is therefore 80. A simple brutefore is beyond most computers as this means there are 2<sup>80</sup> = 1.21 × 10<sup>24</sup> possible key combinations. It should be apparent that breaking a cipher like this isn’t trivial. At first glance it might even seem very secure, but we will show how we can use differential cryptanalysis to break it easily.</p>
      <p>As with the toy cipher, this SPN is easier to understand if you look to the figure below. Remember that the values underlined with purple can be modified. The labels on the side are similar to the ones for the toy cipher with a few changes: we use subscripts to indicate the round number and a new label <i>w</i> is added for the value after the permutation.</p>
      {{spn-visualization.html}}
    </section>
    <section>
      <h3>Differential Cryptanalysis of an SPN</h3>
      <p>This section is partly based on Howard M. Heys’s “A Tutorial on Linear and Differential Cryptanalysis” {cite(heys)}.</p>
      <p>We begin by selecting the SBOX and PBOX for the cipher. We’ll keep the SBOX from the previous section and the default PBOX from the figure above.</p>
      <table class="monospaced-table" id="substitution">
        <tr>
          <th colspan="17">SBOX</th>
        </tr>
        <tr>
          <th>Input:</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
          <td>3</td>
          <td>4</td>
          <td>5</td>
          <td>6</td>
          <td>7</td>
          <td>8</td>
          <td>9</td>
          <td>a</td>
          <td>b</td>
          <td>c</td>
          <td>d</td>
          <td>e</td>
          <td>f</td>
        </tr>
        <tr>
          <th>Output:</th>
          <td>e</td>
          <td>4</td>
          <td>d</td>
          <td>1</td>
          <td>2</td>
          <td>f</td>
          <td>b</td>
          <td>8</td>
          <td>3</td>
          <td>a</td>
          <td>6</td>
          <td>c</td>
          <td>5</td>
          <td>9</td>
          <td>0</td>
          <td>7</td>
        </tr>
      </table>
      <table class="monospaced-table" id="permutation-16">
        <tr>
          <th colspan="17">PBOX</th>
        </tr>
        <tr>
          <th>Input:</th>
          <td>0</td>
          <td>1</td>
          <td>2</td>
          <td>3</td>
          <td>4</td>
          <td>5</td>
          <td>6</td>
          <td>7</td>
          <td>8</td>
          <td>9</td>
          <td>a</td>
          <td>b</td>
          <td>c</td>
          <td>d</td>
          <td>e</td>
          <td>f</td>
        </tr>
        <tr>
          <th>Output:</th>
          <td>0</td>
          <td>4</td>
          <td>8</td>
          <td>c</td>
          <td>1</td>
          <td>5</td>
          <td>9</td>
          <td>d</td>
          <td>2</td>
          <td>6</td>
          <td>a</td>
          <td>e</td>
          <td>3</td>
          <td>7</td>
          <td>b</td>
          <td>f</td>
        </tr>
      </table>
      <p>The first step, just like before, is to calculate the difference distribution table. Since we’re using the same SBOX, it remains unchanged from the previous section.</p>
      <table class="monospaced-table" id="difference-distribution-table">
        <tr>
          <th>Input</th>
          <th colspan="16">Output XOR</th>
        </tr>
        <tr>
          <th>XOR</th>
          <th>0</th>
          <th>1</th>
          <th>2</th>
          <th>3</th>
          <th>4</th>
          <th>5</th>
          <th>6</th>
          <th>7</th>
          <th>8</th>
          <th>9</th>
          <th>a</th>
          <th>b</th>
          <th>c</th>
          <th>d</th>
          <th>e</th>
          <th>f</th>
        </tr>
        <tr>
          <th>0</th>
          <td class="highlight">16</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>1</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>2</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
        </tr>
        <tr>
          <th>3</th>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
        </tr>
        <tr>
          <th>4</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>5</th>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <th>6</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <th>7</th>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
        </tr>
        <tr>
          <th>8</th>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <th>9</th>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>a</th>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
        </tr>
        <tr>
          <th>b</th>
          <td>0</td>
          <td>0</td>
          <td class="highlight">8</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
        </tr>
        <tr>
          <th>c</th>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <th>d</th>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
        </tr>
        <tr>
          <th>e</th>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td class="highlight">4</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
        </tr>
        <tr>
          <th>f</th>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">6</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">4</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
          <td>0</td>
          <td class="highlight">2</td>
          <td>0</td>
        </tr>
      </table>
      <hr/>
      <p>Before we move on we need to discuss permutation. We’ve considered what happens to the XOR of two plaintexts when they go through key addition (it doesn’t change) and when they go through substitution (we can guess it based on the probabilities in the difference distribution table). However, we have not considered what happens when they go through permutation.</p>
      <p>Let’s consider two plaintexts:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p><i>x</i> = 1100 1110 1001 1011</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>x</i><sup>*</sup> = 0011 1110 0101 0111</p>
          </td>
        </tr>
        <tr>
          <td>
            <p><i>x</i> ⊕ <i>x</i><sup>*</sup> = 1111 0000 1100 1100</p>
          </td>
        </tr>
      </table>
      <p>Now let’s send both of these plaintexts through the PBOX:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p>permutate(<i>x</i>) = 1111 1100 0101 0011</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>permutate(<i>x</i><sup>*</sup>) = 0100 0111 1101 1011</p>
          </td>
        </tr>
        <tr>
          <td>
            <p>permutate(<i>x</i>) ⊕ permutate(<i>x</i><sup>*</sup>) = <span class="highlight">1011 1011 1000 1000</span></p>
          </td>
        </tr>
      </table>
      <p>We can see that, unlike key addition, the XOR value before the permutation operation is different than the XOR of the value after the permutation, which could make things difficult. However, what happens if we send the XOR value before the permutation through the PBOX?</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p>permutate(<i>x</i> ⊕ <i>x</i><sup>*</sup>) = permutate(1111 0000 1100 1100) = <span class="highlight">1011 1011 1000 0001</span></p>
          </td>
        </tr>
      </table>
      <p>You should see that both permutate(<i>x</i>) ⊕ permutate(<i>x</i><sup>*</sup>) and permutate(<i>x</i> ⊕ <i>x</i><sup>*</sup>) come out to the same value.</p>
      <p>For some intuition as to why this is true, notice that both of the plaintexts will travel through the same PBOX. If their XOR is 1 at some bit position, it will remain 1 after applying the permutation. It will just move to a different bit position determined by the PBOX. The same logic applies for when their XOR is 0. Therefore, while the XOR doesn’t remain the same, if we know the input XOR (which, remember, we can guess with significant certainty) we can predict the output XOR with 100% certainty by simply putting the XOR through the permutation. One way of writing this more mathematically is:</p>
      <table class="monospaced-table math">
        <tr>
          <td>
            <p>permutate(<i>x</i>) ⊕ permutate(<i>x</i><sup>*</sup>) = permutate(<i>x</i> ⊕ <i>x</i><sup>*</sup>)</p>
          </td>                   
        </tr>                     
      </table>
      <p>The significance of this might not be immediately obvious, but remember that the actual values of <i>x</i> and <i>x</i><sup>*</sup> are essentially impossible to guess, which makes computing permutate(<i>x</i>) ⊕ permutate(<i>x</i><sup>*</sup>) difficult. The value of <i>x</i> ⊕ <i>x</i><sup>*</sup>, on the other hand, is what we’ve been keeping track of this whole time! The PBOX, like the SBOX, is public knowledge so computing permutate(<i>x</i> ⊕ <i>x</i><sup>*</sup>) is very easy.</p>
      <hr/>
      <p>Now that we have discussed all three components let’s quickly review how the XOR interacts with them:</p>
      <ul>
        <li>Key addition: the XOR of two plaintexts <em>does not</em> change over key addition. We can therefore predict the output XOR with 100% certainty.</li>
        <li>Substitution: the XOR of two plaintext <em>does</em> change over substitution. However, it does so probabilistically based on the input XOR and the difference distribution table of the SBOX, which gives us some ability to predict it.</li>
        <li>Permutation: the XOR of two plaintext <em>does</em> change over permutation. However, we can predict it with 100% certainty by simply sending the input XOR through the PBOX.</li>
      </ul>
      <hr/>
      <p>We will now introduce the concept of differential trails (sometimes also called differential characteristics), which expand the idea of differential characteristics we talked about in the previous section. Differential trails are simply a way to keep track of the most likely XOR as two plaintexts make their way through muliple rounds of key addition, substitution, and permutation. The best way to understand it is via an example.</p>
      <p>We begin by picking an input XOR to the cipher: 0xb0b0. Why we picked this input XOR in particular will be explained later on. Below is a figure showing the differential trail explained in the following paragraph. Note that the red lines in the figure do not represent ones in a plaintext but <em>ones in the XOR of two plaintexts as they travel through the cipher</em>.</p>
      <div class="visualization">
        <div class="figure">
          {{../images/diff-trail.svg}}
        </div>
      </div>
      <p>We start with two plaintexts which XOR to 0xb0b0. As they make their way through the key addition, their XOR doesn’t change.</p>
      <p>Next they go through the SBOXes. The SBOX input XOR in their second and fourth nibble is 0 (the plaintexts are equal there) so their XOR doesn’t change in those nibbles. The first and third nibble, however, each have an SBOX input XOR of 0xb. Remember, we cannot predict the SBOX output XOR given the input XOR with 100% certainty. However, we can use the difference distribution table to find the most probable SBOX output XOR for an input XOR of 0xb. In this case, we have a very likely output XOR of 0x2 which occurs 8/16 times (50%). We pick this output XOR for both SBOXes and keep going.</p>
      <p>Some vocabulary: an SBOX with a non-zero input XOR is called an <em class="highlight">active SBOX</em> for that trail. In the first round of the cipher for our differential trail, the first and third SBOXes were active.</p>
      <p>As explained earlier, the XOR of the plaintexts as they go through the permutation can be calculated by simply puting the PBOX input XOR (which is now 0x2020) through the permutation, which leaves us with a value of 0x00a0 at position <i>w</i><sub>1</sub>.</p>
      <p>We now simply continue this process until we get to position <i>u</i><sub>4</sub> in the cipher. Why we stop there will be clear later.</p>
      <p>Now let’s talk about the probability of this full trail occuring. Remember that the only source of uncertainty comes from the SBOXes and, because of the difference distribution table, we know exactly how uncertain we are. For every active SBOX, we picked the most likely output XOR. To get the probability of the trail we simply multiply the probabilities of these output XORs occuring.</p>
      <p>This calculation only works under the assumption that these events are independent, which is not necessarily true. However, this method performs well in practice so we ignore any slight misscalculation. Just be aware that the probability we find is not the <em>true</em> probability of the trail but an approximation of it.</p>
      <p>As you can see in the figure above, the final probability of the whole trail occuring is 0.035 = 3.5%. This is an enormous bias. Remember what this is saying: given two plaintexts which XOR to 0xb0b0, there’s a 3.5% chance that their XOR at position <i>u</i><sub>4</sub> is 0x0808. We will now exploit this bias to break 8 bits of the fifth key.</p>
      <hr/>
      <p>First note that the bits which we will break are the bits coming out of the last round’s active SBOXes (for our trail this means bits 5–8 and 13–16).</p>
      <p>We begin by encrypting two random plaintexts which XOR to 0xb0b0 (remember that differential cryptanalysis is a chosen plaintext attack; we can choose whichever plaintexts we want). Now what we do is attempt to <em>decrypt</em> the message to the end of the differential trail (position <i>u</i><sub>4</sub>) by <em>guessing all possible key bits for bits 5–8 and 13–16</em>. This step is called <em class="highlight">partial decryption</em>. The reason we don’t need to consider key bits 1–4 and 9–12 is because they will not affect the bits 5–8 and 13–16 at <i>u</i><sub>4</sub>, which will be the only ones we care about. The key bits we are breaking are called the <em class="highlight">partial key</em> since they are only a part of the whole key, in our case 8 bits of it.</p>
      <p>Now comes the core of the method. We create a table that keeps track of a count (initialized to 0) for each of the partial keys. <em>Each time the two partially decrypted ciphertexts XOR to the trail’s final XOR (in our case 0x0808), we increment the value for the partial key which was used in the partial decryption.</em></p>
      <p>We then repeat this process for a large number of random plaintext pairs which XOR to 0xb0b0. The partial key with the largest value in the table is most likely the be the correct partial key, meaning we broke 8 bits of the fifth round key!</p>
      <p>Here’s an example of this table after running differential cryptanalysis on our trail, ordered by count. The fifth key was set as 0xb520. The first and third nibble are always set to 0 since we’re not breaking them:</p>
      <table class="monospaced-table" id="count-table">
        <tr>
          <th>Partial Key Value</th>
          <th>Count</th>
        </tr>
        <tr>
          <td>0x0500</td>
          <td>41</td>
        </tr>
        <tr>
          <td>0x050f</td>
          <td>20</td>
        </tr>
        <tr>
          <td>0x0300</td>
          <td>19</td>
        </tr>
        <tr>
          <td>0x0800</td>
          <td>16</td>
        </tr>
        <tr>
          <td>0x050d</td>
          <td>15</td>
        </tr>
        <tr>
          <td>⋮</td>
          <td>⋮</td>
        </tr>
        <tr>
          <td>0x0104</td>
          <td>1</td>
        </tr>
        <tr>
          <td>0x010a</td>
          <td>1</td>
        </tr>
        <tr>
        <td>0x0f04</td>
        <td>1</td>
        </tr>
        <tr>
          <td>0x0f0a</td>
          <td>1</td>
        </tr>
        <tr>
          <td>0x0e07</td>
          <td>1</td>
        </tr>
      </table>
      <p>You can see that the the partial key 0x0500 has the highest count, which is correct since the fifth key’s second nibble is 0x5 and its fourth nibble is 0x0.</p>
      <hr/>
      <p>You should now be left with a few questions:</p>
      <ol>
        <li>Why does this work?</li>
        <li>How do we break the other 8 bits of the fifth round key?</li>
        <li>How do we break the other round keys?</li>
        <li>How many plaintext pairs is enough to break the partial key?</li>
        <li>How do we find good differential trails; or, why did we pick 0xb0b0 as our input XOR?</li>
      </ol>
      <p>We will answer these in order.</p>
      <ol>
        <li>
          <p><b>Why does this work?</b> The basic intuition behind the method is this: if the partial key used for partial <em>decryption</em> was the same key used for the inital <em>encryption</em> (remember, the encryption is done with the correct keys), then we would expect the differential trail to “hold.” In other words, if the partial key guess is correct we would still expect the XOR to be 0x0808 at position <i>u</i><sub>4</sub> with a very high probability (about 3.5% in our case). The count for that partial key would then be incremented.</p>
          <p>If the partial key used for partial decryption <em>does not</em> match the key used for encryption, then that expectation is broken. The value at <i>v</i><sub>4</sub> would be fairly random, meaning that when we put that value through the inverse SBOX to decrypt it to <i>u</i><sub>4</sub>, we would no longer expect the value to be 0x0808 (it could still happen of course, but that would be mostly down to random chance). The count for that partial key would then <em>not</em> be incremented.</p>
          <p>As we repeat this for many plaintext pairs we expect that the true partial key will have the highest count because of the 3.5% bias.</p>
        </li>
        <li>
          <p><b>How do we break the other 8 bits of the fifth round key?</b> Breaking the other 8 bits of the fifth key is very simple: we just need to find a differential trail with different SBOXes active in the last round. If we find a highly probable differential trail with an active first SBOX, then we’ll be able to break bits 1–4. Note that it’s ok if that trail also has other SBOXes active for parts of the key that we’ve already broken. It will just break them again.</p>
        </li>
        <li>
          <p><b>How do we break the other round keys?</b> Breaking the other round keys is also fairly simple. We continue breaking them from the fifth key up.</p>
          <p>For the fourth, third, and second round key we first need to find a differential trail of appropriate length. For the fourth key the trail stops at position <i>u</i><sub>3</sub>, for the third at <i>u</i><sub>2</sub>, etc. You should notice that it’ll be easier to find ones with a bigger bias since the trails will be traveling through fever SBOXes. We must also remember to take permutation into account. It doesn’t change the process but it does affect which key bits are broken by an active SBOX. For example, in our cipher, if the first SBOX is active, we would actually be breaking bits 1, 5, 9, and 13.</p>
          <p>Another important thing to note is that to break the fourth key we need to be able to partially decrypt the ciphertext all the way to position <i>u</i><sub>3</sub>. To do that however, we need the fifth key. In other words, we’re relying on our previous key guesses to break the other round keys. If our guess at the fifth key is incorrect, so will all our other round key guesses.</p>
          <p>Breaking the first key is trivial with simple XOR rules. Send one plaintext through the cipher, decrypt it to position <i>u</i><sub>1</sub> with round keys that are already broken, then simply XOR the original plaintext with this partially decrypted value to get the first round key.</p>
        </li>
        <li>
          <p><b>How many plaintext pairs is enough to break the partial key?</b> Differential cryptanalysis is a probabilistic attack. There’s no guarantee that any of the partial keys you break will be correct. It’s just highly probable that they will be. Consequently, there’s generally a tradeoff between speed and accuracy. The more plaintext pairs that are put through the cipher, the higher the chance of the partial key being broken correctly.</p>
          <p>The reason why the aforementioned tradeoff is only <em>generally</em> true is because, as mentioned earlier, our trail probabilities are approximations. There’s no way to get the trails’ <em>true</em> probabilities. Therefore, no matter how many plaintext pairs are used, it’s still possible to break the partial key incorrectly.</p>
          <p>That being said, the general rule is that the number of plaintext pairs used should be inversely proportional to the probability of the trail.</p>
        </li>
        <li>
          <p><b>How do we find good differential trails?</b> This is just a matter of brute force. You simply try all possible input XORs until you find a highly probable trail. On a small cipher like this even a personal laptop finds them practically instantly. Also note that you only need to find them once, so long as the cipher design remains unchanged.</p>
          <p>There is a catch though. Remember that the number of bits that are broken in a partial key depends on the number of active SBOXes at the end of the trail. Remember also that we need to loop through all possible key bits for the bits we’re breaking. If there are only two active SBOXes at the end of our trail, that means we need to loop through 2<sup>8</sup> possible partial keys for each plaintext pair. If all four SBOXes are active, we need to loop through 2<sup>16</sup> possible partial keys for each plaintext pair, which is 256 times slower.</p>
          <p>In other words, if we want to minimize the time it takes to break the keys, we not only need to find a trail which is highly probable (so that fewer plaintext pairs will be needed), but one which has as few active SBOXes in the last round of the trail as possible.</p>
        </li>
      </ol>
    </section>
  </section>
  <section>
    <header>
      <h2>Modern Cryptography</h2>
      <blockquote>
        <p>I have said enough to convince you that ciphers of this nature are readily soluble, and to give you some insight into the rationale of their development. But be assured that the specimen before us appertains to the very simplest species of cryptograph.</p>
        <cite>—Poe</cite>
      </blockquote>
      <div class="visualization">
        <div class="figure">
          {{../images/aes.svg}}
        </div>
      </div>
    </header>
    <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
  </section>
  <section>
    <h2>Bibliography</h2>
    <ol id="bibliography">
      <li id="biham">Biham, Eli and Adi Shamir. “Differential Cryptanalysis of DES-like Cryptosystems.” <i>Journal of Cryptology</i> 4, no. 1 (January 1991): 3–72. https://doi.org/10.1007/BF00630563.</li>
      <li id="coppersmith">Coppersmith, Don. “The Data Encryption Standard (DES) and its strength against attacks” <i>IBM Journal of Research and Development</i> 38, no. 3 (May 1994): 243–250. https://doi.org/10.1147/rd.383.0243.</li>
      <li id="heys">Heys, Howard M. “A Tutorial on Linear and Differential Cryptanalysis.” <i>Cryptologia</i> 26, no. 3 (July 2002): 189–221. https://doi.org/10.1080/0161-110291890885.</li>
      <li id="king">King, Jon. “Differential Cryptanalysis Tutorial.” The Amazing King. http://theamazingking.com/crypto-diff.php.</li>
      <li id="stinson">Stinson, Douglas R. <i>Cryptography: Theory and Practice</i>. Chapman and Hall/CRC, 2006.</li>
    </ol>
  </section>
</section>
<script src="js/generate-section-numbers.js"></script>
<script src="js/generate-citation-numbers.js"></script>
<script src="js/generate-toc.js"></script>
